# Работа с Git
## Проверка наличия установленного Git

В терминале выполнить команду ```git  ---version```

Если Git установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## Установка Git

[Загружаем последнюю версию Git с сайта https://git-scm.com/download](https://git-scm.com/download)

Устанавливаем с настройками по умолчанию.

## Настройка Git

После первого входа, необходимо представиться системе.

В терминале прописываем следующие команды:

```git config --global user.name``` «Ваше имя англ буквами»

```git config --global user.email``` ваша_почта@example.com

Первая команда запомнит Ваше имя в системе, вторая запомнит Ваш e-mail. Желательно указывать реальный адрес почты и имя, это упростит командную работу.

Далее необходимо инициализировать репозиторий Git, место где будут храниться файлы отслеживаемые системой контроля версий.

Для этого через терминал используем команду  `git init` с локальной ссылкой на папку, где будут храниться файлы, изменение которых необходимо будет отслеживать.

Например:
> ```git init C:\Users\%username%\Desktop\Homework#1```

Далее создаем файл в данном репозитории и добавляем его в систему контроля версий.

Для этого используем команду `git add` и далее указываем имя файла который необходимо добавить. 

Например:
> ```git add .\Homework1.md```

Минутка лайфхаков:

>*Можно использовать кнопку TAB на клавиатуре, тогда в команде `add` имя файла подтянется автоматически.*

>*Если Вы испольуете VSC, при запуске в стартовом окне "Начало работы" представится возможность выбрать папку, файлы в которой будут остлеживаться контролем версий, и затем просто прописать команду `git init` без точного указания пути к папке*

После добавления файла также необходимо использовать команду `git commit -m "Ваш комментарий"` , для того чтобы система начала отслеживать изменения в нём. Это своеобразная точка отсчета контроля версий файла, после которой появится возможность запоминать все последующие изменения файла и при необходимости возвращаться к предыдущим версиям.

Например:
>```git commit -m "Создали файл"```

Таким образом, подводя итоги в результате вышеописанных действий Вы:
1. Представились системе Git, указали своё имя и e-mail.
2. Инициализировали репозиторий в котором система будет отслеживать изменения файлов.
3. Начали контролировать версию первого файла, дальнейшие изменения в нём система будет отслеживать.

## Основные команды в Git


Вводя в терминал следующие команды, Вы сможете отслеживать изменения в файлах, возвращаться к предыдшим версиям своих файлов, искать и исправлять ошибки, откатывать изменения.
1. После изменения файла, которые вы хотите сохранить, необходимо использовать команды `git add <имя файла>` и команды `git commit -m  "комментарий"`. 

    Команды добавят текущую версию файла в историю изменений с комментарием о внесенных изменениях в файл.
    
     *ВАЖНО! Не забывайте сохранять файл перед использованием данных команд, командами ctrl+s или cmd+s (Mac)*

    Пример последовательности написания команд в терминале:

    > `git add <имя файла>` 

    > `git commit -m "Комментарий"`
2. Следующая команда `git status` покажет проиндексированные но не отслеживаемые файлы, то есть когда Вы внесли изменения в файл, сохранили его, но не выполнили команды из п.1., т.е. не "запомнили" системой новую версию.
    
    Пример того, что Вам покажет программа, при наличи подобных изменений:
    > Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   Homework1.md

    Система сама подскажет Вам команды, в зависимости от того, что Вы хотите сделать в данной ситуации `git restore <имя файла>` для отката изменений, либо `git add <имя файла>` для сохранения и последующего `commit` этого файла.
3. Для просмотра истории изменений используйте команду `git log`, она покажет список  Ваших `commit` `ов с комментариями которые Вы указывали, а также хэш-код версий файла, с помощью него Вы сможете вернуться к необходимой версии и об этом расскажем чуть позже.

    Пример вывода данной операции:
    > commit a72a59006b28a1e42209066f0f2531a68bde9aeb
    
    >Author: Evgeniy <ugin2308@mail.ru>

    >Date:   Mon Jan 17 00:41:51 2022 +0300

    >Создан раздел Основные команды гит, добавлен п.1
4. Для просмотра разницы между текущей сохраненной но `не запомненной` и последней сохраненной `запомненной` версией файла, или `запомненной` ещё ранее через команду `commit`, можно использовать команду `git diff` с указанием хэш кода `commit` (для более ранних версий) который можно получить c помощью команды `git log` указанной в п.3. Результатом данной операции будет отображения всех изменений внесенных в файл относительно версии к сравнению.
    
    Пример написания данной команды, с использованием хэш кода из п.3
    > ```git diff a72a59```
    
    *Примечание: не обязательно брать хэш-код целиком, Git достаточно первых 4-6 символов кода для того чтобы распознать конкретную версию. Если нет необходимости сравнивать с версиями предшествующими последнему `commit` хэш-код указывать не требуется.*
5. Для просмотра одной из ранее сохраненных версий файла, можно воспользоваться командой `git checkout <хэш код commit>`. В этом случае Вы перейдете к версии файла которая была сохранена ранее, для правок или просмотра. Для того, чтобы вернуться к последней сохраненной версии файла используйте комманду `git checkout master`.
    
    Пример написания данной команды, с использованием хэг кода из п.3
    > `git checkout a72a59`
    
    Для выхода из режима просмотра
    > `git checkout master`

    Также возможно использовать комманды `git add` и `git commit` если нет необходимости возвращаться к "актуальной" версии.


 # Ветки в Git.

В Git реализована возможность создания отдельных веток проекта, места где можно работать над различными участками проекта, вносить изменения, запоминать и затем сливать эти изменения с основной веткой проекта.
Это очень удобно когда над одним файлом работают сразу несколько человек, их зоны ответственности разделены, или наоборот пересекаются между собой, и каждый может независимо от остальных участников, представить своё видение на отдельной ветке. Затем по мере необходимости соединив это с основной веткой проекта.

## Создание новой ветки

Для создания новой ветки проекта используйте команду `- git branch <new branch name>`

Для проверки своего "местоположения" используйте команду `- git branch` где симовлом `(*)` будет отмечена ветка в котрой вы сейчас находитесь.

Для перехода в другую ветку используйте команду `git checkout <branch_name>`

Так выглядит типовой лог операций при создании новой ветки с последующей проверкой своего местоположения и перемещение в дереве версий:


![P14](Primer14.jpg)

Ваши действия в новой ветке можно записывать и сохранять абсолютно также как и в основной ветке проекта. Комманды `-git add <filename>`, `git commit -m "комментарий"` выполняют те же роли, что в ветке мастер, по прежнему остается возможным контроль версий файла, команда `git log` покажет все `commit` `ы, которые были в файле c детализацией по веткам.

Лог при этом будет следующий:

![P17](Primer17.jpg)


# Функциональность.

## Удобные команды для навигации
Удобной командой для понимания того, как развивался проект и какие ветки были слиты можно с помощью команды `-git reflog`.

Также визуализировать историю версиий c разбивкой по веткам можно с помощью команды `-git log --graph`

Свёрнутая версия этой команды, на мой взгляд, более удобная для четния `-git log --graph --oneline`.

## Операции с ветками 
При работе с ветками, Вам возможно захочется принять изменения из одной веток, перенести их в основную, либо же отказаться от необходимости этих изменений, для этого Вам помогут следующие команды.

Соединить две ветки в одну можно с помощью команды `-git merge <branch_name>`. После чего система соединит текущую ветку в которой Вы находитесь, с веткой указанной в `<>`. 

Когда ветки сливаются без ошибок, записи в терминале следующие:


![P17](Primer18.jpg)

Иногда, ряд веток становится не нужным для дальнейшего контроля, соответственно их можно удалить. Для этого можно воспользоваться командой `git branch -d <branch_name`>. 

Пример последовательности данной операции Вы можете наблюдать на картинке ниже:

![P15](Primer15.jpg)

![P16](Primer16.jpg)



## Конфликтные ситуации. Реальный опыт решения и мысли в слух возникшие в процессе выполнения домашней работы.

Насколько я понял - Git подразумевает структурированную работу с документом, чтобы участки редактирования были заранее оговорены, т.к. замена больших блоков отнимает много сил на анализ расхождений. Тем не менее, из данного файла я создал две ветки, одна из которых `scrsh` а другая `konflikt`. Первой была крайняя ветка. В этой ветке я внёс исправление в текущий блок. Сохранил файл и перешел в ветку `scrsh`.

>>На самом деле веток, по ходу изучения функционала я насоздавал много, но не записывал об этом информацию, изначальные две я так и оставил в финальном проекте.

Конфликт чаще всего возникает, когда заполнение файла идет не последовательно, новые блоки не увязываются между собой, в новых ветках стирается или перезаписывается информация в смежных строках с веткой `master`, соответственно надо сохранять файл постоянно, желательно при этом всегда отслеживая где и в каком состоянии его ветки на текущий момент Вы находитесь, регулярно используйте команды `-git status`, `-git branch` чтобы не потеряться.

>*Совет от чайника*:

>Финальные версии веток через `merge` агрегируйте в ветке мастер и затем удаляйте их, т.к. внеся изменения в дельта-ветки, и сливая их между собой, можно нарваться на то, что основной ствол уйдет в дельту и вы потеряете свои `commit`ы, у меня такое случилось по ходу разбора веток несколько раз.Хорошим тоном, насколько я понял, будет являться удаление веток, которые мы слили с мастер веткой, и созание новых веток из `master` версии по мере продвижения, т.к. актуализация индексов и информации в файле крайне важна. Очень много конфликтов возникает когда "старые" версии проекта сливаются с актуальными. Старайтесь, по-возможности, ветки вести относительно крайней актуальной версии файла, это важно.

Например при добавлении ветки `scrsh` с упоряд. списком всех скринов не вызвало каких либо конфликтов при слиянии, а последующее слияние с веткой `konflikt` привело к ошибке такого рода:
>![P11](Primer11.jpg)

На выбор будет предложено либо принятие какого-то одного участка, обеих вариантов, либо сравнение их между собой.

Такой конфликт кажется не сложным, если у Вас разница в небольшом участке:
![P12](Primer12.jpg)


И гораздо сложнее на "объемных участках" проекта:

![P7](Primer8.jpg)

* > *Обратите внимание, сверху указана текущая версия HEAD и выделена зеленым цветом,Синим цветом выделено входящее изменение даннного участка файла.*

Следует добавлять все изменения последовательно, резкие правки и вставки губят.

Также верный способ избежать конфликтных ситуаций, сразу после `merge` и разрешения ситуации с конфликтом показанным выше незамедлительно сохранить файл через команды `git add` и `git commit`, иначе при переходе в другие ветки и правки в них, возникнет конфликт версионности файла.
Вот как визуально проявляется информация о том, что файл находится в состоянии конфликта:

>![P13](Primer13.jpg)


 >Не совсем понял как, но есть вероятность, что если после коммита о решенном конфликте добавлять новую информацию в `master` и делать повторный `add + commit` то новая версия не потянет за собой конфликтов.
 >>>*ушел пробовать*" 

 >> update. Работает!

Остальные конфликтые ситуации связаны с потерей версиии файла, очень важно, строго запоминать все изменения в ветках проекта `step by step`, иначе при несохраненных изменения в одной ветке, переход в другую и сохранение изменений в ней может приветси к потере данных в изначальной ветке. При слиянии также возникнут ошбики.

Но тем не менее, если Вы всё таки потерялись в версиях/ветках/слияниях, как и я в процессе создания этого файла, Вы всегда можете использовать команду `git checkout <хэш-код commit>`. После чего система перенесет Вас к определенной версии проекта, и если она Вас устраивает Вы можете создать из неё отдельную ветку в текущем проекте с помощью команды `git switch -c <new_branch_name>`, в дальнейшем соединив или заменив ею ветку `master` при слиянии.


# Скриншоты конфилктов с кратиким описанием

>От идеи со скриншотами решил отказаться. Много лишней информации, все необходимые указаны ранее

# Мысли в слух.

По итогу, мне стало ясно, что все изменения должны быть четко и последовательно фиксированы, и не стоит хранить супер древние версии веток, во избежании конфликтов при слиянии. Как можно чаще сверять своё местоположение перед сохранением изменений, актуализировать ветки относительно "рабочей" версии файла для "безболезненных `mergeй`
Старые ветки желательно удалять сразу послет того как они выполнили свою роль.

# Работа с удаленными репозиториями Git.

## Введение

Ранее описанные примеры работы с Git рассматривались исключительно как работа с локальным репозиторием, т.е. тем, что находится непосредственно на нашем оборудовании. Но также Git поддерживает опцию удаленного размещения своего репозитория на специализированных ресурсах.

Одним из самых популярных ресурсов, где разработчики размещают свои проекты называется - [Github](https://github.com/)

На нём Вы можете хранить файлы своих проектов, загружать и выгружать репозитории,  подключаться к ним с любого устройства. Смотреть чужие проекты, принимать в них участие (если они публичные, конечно), обмениваться идеями с другими разработчиками и многое другое.

### Регистрация на Github.

Перед началом работы с удаленным репозиториями, сперва Вам необходимо зарегестрироваться на [Github](https://github.com/).

Процесс регистрации довольно прост, и не отнимет у Вас много сил и времени.


## Основные команды при работе с удаленными репозиториями.

Первая команда, которая позволяет "вытянуть" с сайта-хранилища репозиториев проект к себе на локальное устройство - `git clone <url адрес репозитория>`.

*Имейте ввиду, что речь идет о публичных репозиториях, при работе над серьезными проектами, корпоративной разработкой, каждому участнику предоставляется индивидуальный доступ к такой опции*

Итак, данная команда создаст точную копию репозитория размещенного на сайте, Вы сможете работать в нём так, словно он Ваш, весть стандартный набор комманд `add, init, commit,  branch` и прочие, о которых речь шла ранее, будут доступны к использованию.

В данном случае, Вы создали клон имеющегося репозитория.

Для получения полного доступа, к репозиторию, используйте команду
