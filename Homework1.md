# Работа с Git
## Проверка наличия установленного Git

В терминале выполнить команду ```git  ---version```

Если Git установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## Установка Git

[Загружаем последнюю версию Git с сайта https://git-scm.com/download](https://git-scm.com/download)

Устанавливаем с настройками по умолчанию.

## Настройка Git

После первого входа, необходимо представиться системе.

В терминале прописываем следующие команды:

```git config --global user.name``` «Ваше имя англ буквами»

```git config --global user.email``` ваша_почта@example.com

Первая команда запомнит Ваше имя в системе, вторая запомнит Ваш e-mail. Желательно указывать реальный адрес почты и имя, это упростит командную работу.

Далее необходимо инициализировать репозиторий Git, место где будут храниться файлы отслеживаемые системой контроля версий.

Для этого через терминал используем команду  `git init` с локальной ссылкой на папку, где будут храниться файлы, изменение которых необходимо будет отслеживать.

Например:
> ```git init C:\Users\%username%\Desktop\Homework#1```

Далее создаем файл в данном репозитории и добавляем его в систему контроля версий.

Для этого используем команду `git add` и далее указываем имя файла который необходимо добавить. 

Например:
> ```git add .\Homework1.md```

Минутка лайфхаков:

>*Можно использовать кнопку TAB на клавиатуре, тогда в команде `add` имя файла подтянется автоматически.*

>*Если Вы испольуете VSC, при запуске в стартовом окне "Начало работы" представится возможность выбрать папку, файлы в которой будут остлеживаться контролем версий, и затем просто прописать команду `git init` без точного указания пути к папке*

После добавления файла также необходимо использовать команду `git commit -m "Ваш комментарий"` , для того чтобы система начала отслеживать изменения в нём. Это своеобразная точка отсчета контроля версий файла, после которой появится возможность запоминать все последующие изменения файла и при необходимости возвращаться к предыдущим версиям.

Например:
>```git commit -m "Создали файл"```

Таким образом, подводя итоги в результате вышеописанных действий Вы:
1. Представились системе Git, указали своё имя и e-mail.
2. Инициализировали репозиторий в котором система будет отслеживать изменения файлов.
3. Начали контролировать версию первого файла, дальнейшие изменения в нём система будет отслеживать.

## Основные команды в Git


Вводя в терминал следующие команды, Вы сможете отслеживать изменения в файлах, возвращаться к предыдшим версиям своих файлов, искать и исправлять ошибки, откатывать изменения.
1. После изменения файла, которые вы хотите сохранить, необходимо использовать команды `git add <имя файла>` и команды `git commit -m  "комментарий"`. 

    Команды добавят текущую версию файла в историю изменений с комментарием о внесенных изменениях в файл.
    
     *ВАЖНО! Не забывайте сохранять файл перед использованием данных команд, командами ctrl+s или cmd+s (Mac)*

    Пример последовательности написания команд в терминале:

    > `git add <имя файла>` 

    > `git commit -m "Комментарий"`
2. Следующая команда `git status` покажет проиндексированные но не отслеживаемые файлы, то есть когда Вы внесли изменения в файл, сохранили его, но не выполнили команды из п.1., т.е. не "запомнили" системой новую версию.
    
    Пример того, что Вам покажет программа, при наличи подобных изменений:
    > Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   Homework1.md

    Система сама подскажет Вам команды, в зависимости от того, что Вы хотите сделать в данной ситуации `git restore <имя файла>` для отката изменений, либо `git add <имя файла>` для сохранения и последующего `commit` этого файла.
3. Для просмотра истории изменений используйте команду `git log`, она покажет список  Ваших `commit` `ов с комментариями которые Вы указывали, а также хэш-код версий файла, с помощью него Вы сможете вернуться к необходимой версии и об этом расскажем чуть позже.

    Пример вывода данной операции:
    > commit a72a59006b28a1e42209066f0f2531a68bde9aeb
    
    >Author: Evgeniy <ugin2308@mail.ru>

    >Date:   Mon Jan 17 00:41:51 2022 +0300

    >Создан раздел Основные команды гит, добавлен п.1
4. Для просмотра разницы между текущей сохраненной но `не запомненной` и последней сохраненной `запомненной` версией файла, или `запомненной` ещё ранее через команду `commit`, можно использовать команду `git diff` с указанием хэш кода `commit` (для более ранних версий) который можно получить c помощью команды `git log` указанной в п.3. Результатом данной операции будет отображения всех изменений внесенных в файл относительно версии к сравнению.
    
    Пример написания данной команды, с использованием хэш кода из п.3
    > ```git diff a72a59```
    
    *Примечание: не обязательно брать хэш-код целиком, Git достаточно первых 4-6 символов кода для того чтобы распознать конкретную версию. Если нет необходимости сравнивать с версиями предшествующими последнему `commit` хэш-код указывать не требуется.*
5. Для просмотра одной из ранее сохраненных версий файла, можно воспользоваться командой `git checkout <хэш код commit>`. В этом случае Вы перейдете к версии файла которая была сохранена ранее, для правок или просмотра. Для того, чтобы вернуться к последней сохраненной версии файла используйте комманду `git checkout master`.
    
    Пример написания данной команды, с использованием хэг кода из п.3
    > `git checkout a72a59`
    
    Для выхода из режима просмотра
    > `git checkout master`

    Также возможно использовать комманды `git add` и `git commit` если нет необходимости возвращаться к "актуальной" версии.


 # Ветки в Git.

В Git реализована возможность создания отдельных веток проекта, места где можно работать над различными участками проекта, вносить изменения, запоминать и затем сливать эти изменения с основной веткой проекта.
Это очень удобно когда над одним файлом работают сразу несколько человек, их зоны ответственности разделены, или наоборот пересекаются между собой, и каждый может независимо от остальных участников, представить своё видение на отдельной ветке. Затем по мере необходимости соединив это с основной веткой проекта.

## Создание новой ветки

Для создания новой ветки проекта используйте команду `- git branch <new branch name>`

Для проверки своего "местоположения" используйте команду `- git branch` где симовлом `(*)` будет отмечена ветка в котрой вы сейчас находитесь.

Для перехода в другую ветку используйте команду `git checkout <branch_name>`

Так выглядит типовой лог операций при создании новой ветки с последующей проверкой своего местоположения и перемещение в дереве версий:


![P14](Primer14.jpg)

Ваши действия в новой ветке можно записывать и сохранять абсолютно также как и в основной ветке проекта. Комманды `-git add <filename>`, `git commit -m "комментарий"` выполняют те же роли, что в ветке мастер, по прежнему остается возможным контроль версий файла, команда `git log` покажет все `commit` `ы, которые были в файле c детализацией по веткам.

Лог при этом будет следующий:

![P17](Primer17.jpg)


# Функциональность.

## Удобные команды для навигации
Удобной командой для понимания того, как развивался проект и какие ветки были слиты можно с помощью команды `-git reflog`.

Также визуализировать историю версиий c разбивкой по веткам можно с помощью команды `-git log --graph`

Свёрнутая версия этой команды, на мой взгляд, более удобная для четния `-git log --graph --oneline`.

## Операции с ветками 
При работе с ветками, Вам возможно захочется принять изменения из одной веток, перенести их в основную, либо же отказаться от необходимости этих изменений, для этого Вам помогут следующие команды.

Соединить две ветки в одну можно с помощью команды `-git merge <branch_name>`. После чего система соединит текущую ветку в которой Вы находитесь, с веткой указанной в `<>`. 

Когда ветки сливаются без ошибок, записи в терминале следующие:


![P17](Primer18.jpg)

Иногда, ряд веток становится не нужным для дальнейшего контроля, соответственно их можно удалить. Для этого можно воспользоваться командой `git branch -d <branch_name`>. 

Пример последовательности данной операции Вы можете наблюдать на картинке ниже:

![P15](Primer15.jpg)

![P16](Primer16.jpg)



## Конфликтные ситуации. Реальный опыт решения и мысли в слух возникшие в процессе выполнения домашней работы.

Насколько я понял - Git подразумевает структурированную работу с документом, чтобы участки редактирования были заранее оговорены, т.к. замена больших блоков отнимает много сил на анализ расхождений. Тем не менее, из данного файла я создал две ветки, одна из которых `scrsh` а другая `konflikt`. Первой была крайняя ветка. В этой ветке я внёс исправление в текущий блок. Сохранил файл и перешел в ветку `scrsh`.

>>На самом деле веток, по ходу изучения функционала я насоздавал много, но не записывал об этом информацию, изначальные две я так и оставил в финальном проекте.

Конфликт чаще всего возникает, когда заполнение файла идет не последовательно, новые блоки не увязываются между собой, в новых ветках стирается или перезаписывается информация в смежных строках с веткой `master`, соответственно надо сохранять файл постоянно, желательно при этом всегда отслеживая где и в каком состоянии его ветки на текущий момент Вы находитесь, регулярно используйте команды `-git status`, `-git branch` чтобы не потеряться.

>*Совет от чайника*:

>Финальные версии веток через `merge` агрегируйте в ветке мастер и затем удаляйте их, т.к. внеся изменения в дельта-ветки, и сливая их между собой, можно нарваться на то, что основной ствол уйдет в дельту и вы потеряете свои `commit`ы, у меня такое случилось по ходу разбора веток несколько раз.Хорошим тоном, насколько я понял, будет являться удаление веток, которые мы слили с мастер веткой, и созание новых веток из `master` версии по мере продвижения, т.к. актуализация индексов и информации в файле крайне важна. Очень много конфликтов возникает когда "старые" версии проекта сливаются с актуальными. Старайтесь, по-возможности, ветки вести относительно крайней актуальной версии файла, это важно.

Например при добавлении ветки `scrsh` с упоряд. списком всех скринов не вызвало каких либо конфликтов при слиянии, а последующее слияние с веткой `konflikt` привело к ошибке такого рода:
>![P11](Primer11.jpg)

На выбор будет предложено либо принятие какого-то одного участка, обеих вариантов, либо сравнение их между собой.

Такой конфликт кажется не сложным, если у Вас разница в небольшом участке:
![P12](Primer12.jpg)


И гораздо сложнее на "объемных участках" проекта:

![P7](Primer8.jpg)

* > *Обратите внимание, сверху указана текущая версия HEAD и выделена зеленым цветом,Синим цветом выделено входящее изменение даннного участка файла.*

Следует добавлять все изменения последовательно, резкие правки и вставки губят.

Также верный способ избежать конфликтных ситуаций, сразу после `merge` и разрешения ситуации с конфликтом показанным выше незамедлительно сохранить файл через команды `git add` и `git commit`, иначе при переходе в другие ветки и правки в них, возникнет конфликт версионности файла.
Вот как визуально проявляется информация о том, что файл находится в состоянии конфликта:

>![P13](Primer13.jpg)


 >Не совсем понял как, но есть вероятность, что если после коммита о решенном конфликте добавлять новую информацию в `master` и делать повторный `add + commit` то новая версия не потянет за собой конфликтов.
 >>>*ушел пробовать*" 

 >> update. Работает!

Остальные конфликтые ситуации связаны с потерей версиии файла, очень важно, строго запоминать все изменения в ветках проекта `step by step`, иначе при несохраненных изменения в одной ветке, переход в другую и сохранение изменений в ней может приветси к потере данных в изначальной ветке. При слиянии также возникнут ошбики.

Но тем не менее, если Вы всё таки потерялись в версиях/ветках/слияниях, как и я в процессе создания этого файла, Вы всегда можете использовать команду `git checkout <хэш-код commit>`. После чего система перенесет Вас к определенной версии проекта, и если она Вас устраивает Вы можете создать из неё отдельную ветку в текущем проекте с помощью команды `git switch -c <new_branch_name>`, в дальнейшем соединив или заменив ею ветку `master` при слиянии.


# Скриншоты конфилктов с кратиким описанием

>От идеи со скриншотами решил отказаться. Много лишней информации, все необходимые указаны ранее

# Мысли в слух.

По итогу, мне стало ясно, что все изменения должны быть четко и последовательно фиксированы, и не стоит хранить супер древние версии веток, во избежании конфликтов при слиянии. Как можно чаще сверять своё местоположение перед сохранением изменений, актуализировать ветки относительно "рабочей" версии файла для "безболезненных `mergeй`
Старые ветки желательно удалять сразу послет того как они выполнили свою роль.

# Работа с удаленными репозиториями Git.

## Введение

Ранее описанные примеры работы с Git рассматривались исключительно с точки зрения работы с локальным репозиторием, тем что находится непосредственно на нашем устройстве. Но Git также поддерживает функцию работы с удаленно размещенными репозиториями на специализированных ресурсах.

Одним из самых популярных ресурсов, где разработчики, программисты размещают свои проекты называется - [Github](https://github.com/)

На нём Вы можете хранить репозитории с файлами своих проектов, загружать и выгружать репозитории,  подключаться к ним с любого устройства. Смотреть чужие проекты, принимать в них участие (если они публичные, конечно), обмениваться идеями с другими разработчиками и многое другое.

### Регистрация на Github.

Перед началом работы с удаленным репозиториями сперва Вам необходимо зарегестрироваться на [Github](https://github.com/), создать в нём аккаунт и свой первый репозиторий, хотя по умолчянию он там уже будет с файлом README.

Процесс регистрации предельно простой, не будем на этом заострять внимание и сразу перейдем непосредственно к функционалу работы с удаленными репозиториями.


## Основные команды при работе с удаленными репозиториями.

#

* Первая команда, которая позволяет создать клон проекта с `сайта-хранилища репозиториев` проект к себе на локальное устройство - `git clone <url адрес репозитория>`.



Данная команда создаст точную копию репозитория размещенного на сайте, Вы сможете работать в нём так, словно он Ваш, весь стандартный набор комманд `add, init, commit,  branch` и прочие, о которых речь шла ранее, будут доступны к использованию.



* Следующие команды позволят разместить Ваш локальный репозиторий на свою страницу в `Github`, или другом аналогичном ему ресурсе, для этого необходимо указать в терминале ряд команд:

     `git remote add origin <url Вашего репозитория на Github>`

    `git remote branch -M <имя ветки которую направляем>`

    `git remote push -u origin <имя ветки которую направляем>`

Первая из списка команд установит адрес страницы в интернете, куда Вы направите и с которой будете отслеживать Ваш репозиторий. Второй командой Вы определяете имя `master` ветки которая будет размещена, а третья команда выполнит операцию по непосредственной загрузке репозитория на `Github`.

 *Обратите внимание, что при первом "пуше" локального репозитрия, система попросит Вас авторизоваться через `GitHub` (или другой аналогичный ресурс), чтобы подтвердить что Вы доверенный пользователь данного репозитория. Также `Github` сам подскажет каким образом можно сделать `push` локального проекта, при создании <url ссылки> репозитория на сайте.*

 Указание мастер ветки, при загрузке репозитория, является неотъемлеммой и обязательной частью процесса, если у проекта много веток, укажите основную в которой ведется работа.

 После авторизации и первого успешного `push` с авторизацией, Вы можете перейти на `Github`, обновить страницу репозитория и увидеть свой проект на сайте. Теперь вы можете работать с ним с любого устройства, при необходимости, другие пользователи могут видеть проект  и взаимодействовать с ним при желании создавая клоны и предлагая Вам что-то в нём изменить, конечно если проект в статусе `public`.
 
В дальнейшем при работе с данным репозиторием локально, для того чтобы данные о новых `commit` попадали "в сеть", необходимо указывать в терминале команду - `git push` , и данные будут обновляться на странице с репозиторием `Github`.



 * Командой, являющейся противоположной, или обратной `git push`  является команда `git pull`. Данная команда, подходит для случаев, когда проект размещен на `Github` или другом аналогичном ресурсе, и Вы ведет работу над проектом с разных устройств, как следствие, Ваша локальная версия проекта может "отставать" от актуальной размещенной на `Github`. Соответственно для того, чтобы актуализировать репозиторий, используем следующую команду:

    `git pull`


*Обратите внимание, выполнение данной команды также сделает `merge` локального и удаленного репозиториев, соответственно возможны конфликты в процессе выполнения данной операции, аналогичные конфликтам при слиянии веток* 


    
    Edit для перового Pull.


Также работать с проектами других пользователей `Github` можно через Fork и Pull request. Давайте разберемся что же это такое.

Перейдя на страницу другого пользователя, чей проект Вас заинтересовал, Вы можете добавить его репозиторий к себе на `Github` нажав кнопку `Fork` в правом верхнем углу.
При этом, на странице репозитория будет указан изначальный автор `Forked from <@USERNAME@>`, но работать с проектом Вы сможете так, как будто он Ваш, совершая все ранее указанные операции.

Далее Вы можете сделать `clone` данного проекта, обновить в нём что-то, затем сделать `push` в "свою копию" на `GitHub`. И после успешного пуша, на старнице `Github` вы увидите сообщение с предложением принять изменения и отправить `Pull request` автору оригинального репозитория, с укзаанием комментария о проделанной работе.

Данный метод очень актуален для `open-source` проектов.

*Также обратите внимание, что хорошим тоном считается работа в отдельных от основной ветках чужого проекта, вряд ли кто-то захочет принять изменения основной ветки от постороннего.*